## TimSort 简介
### 背景介绍
TimSort是由Tim Peters在2002年设计并实现的排序算法，并应用在了python语言中。随后java8等语言也将默认的排序算法由快速排序替换为了timsort，使该算法成为了当前最流行且被广泛使用的排序方法。

### 核心思路
TimSort算法认为现实世界中数据的最重要特点是整体相对有序，从而针对性的优化了归并算法。传统排序算法除了基数排序外，都会忽略数据本身的特性，是偏实验室理论的。

算法把完整数据划分成多个子序列（分片），然后进行合并。每个子序列称为一个run。归并排序是基于原始的二分查找的思路进行子序列划分和合并的。TimSort的重大改进是，把数据按照顺序或者逆序进行子序列的划分。随后，TimSort对这些划分好的有序的run进行合并，直到数据排序完成。

对于数列  12365445678954321, 划分的run为123, 654, 456789, 54321。
- 如果只使用单一顺序，那么一定会出现单个数字为一列，效率就会很低。因此，必须同时采用顺序和逆序的子序列。
- 另一方面，现实世界中的数据大部分都能满足这种成片的连续性，因此这种合并的效率会非常高。对于两个有序数列的合并，是采用A[i]和B[j]两两相比的方式。因此，比较次数最少为min(len(a),len(b)),比较次数最为len(a)+len(b)-1。

### 实现细节
- MIN_LENGHTH:对于小数据，套用如此复杂的排序方式是没有必要。因此当数据量小于MIN_LENGTH时，直接使用原有的排序方式。
- MIN_RUN：过小的RUN也会导致算法效率的大幅下降。因此当进行RUN划分时，如果划分出来的RUN如果小于MIN_RUN,那么补足到MIN_RUN并进行一次额外的排序。
- MIN_GALLOP: 对于两个数组的合并效率，TimSort在代码实现时做了进一步的优化。假设A数组比较短，B数组比较长。那么在合并时，会拿A序列插入到B序列。如果B序列很长，大于了MIN_GALLOP阈值，那么不断拿A[i]和B[j++]是个速率很慢的过程，更高效的方式是采用斐波那契数列选取B的下标，例如B[0],B[1],B[3],B[7]...这样可以更快速的进行merge操作。
- mergeHi & mergeLo: merge High和merge Low是指merge两个run时的具体顺序，即从高位开始比较merge，还是从低位开始。由于存在顺序序列和逆序序列，因此要么反转部分序列，要么就根据顺序选择是mergeHi还是mergeLo。另一种情况则是在Gallop模式时，指定一个run中的部分区间与另一个run按特定顺序进行merge。
### 小结
写一个sort方法需要满足如下原则
- 传递性： A>B & B>C -> A>C
- 自反性： A=A
- 对称性： A>B -> B>A

本次crash点在timsort.mergeHi,即在gallop模式时出现了崩溃。原因是代码不满对称性，即传入的item1和item2位置互换后，大小关系可能会出错。

由于timsort的过程中不保证数据的传入顺序，因此一旦数据量变大超过MIN_LENGHTH，首先就会跃过基础排序进入timsort，此时出问题几率就会变大。等数据量大到出现run的数据个数大于MIN_GALLOP以后，进入到gallop模式，mergeHi出现的几率就会进一步提高。通过随机生成大量数据(>100条)，就可以稳定复现此类问题。

补充一个猜测是，由于最近放开了循环会议的展现方式，使拥有循环会议的人在列表中一下子多出来大量的会议，导致了该问题较为明显的暴露了出来。